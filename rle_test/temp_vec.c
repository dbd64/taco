// Generated by the Tensor Algebra Compiler (tensor-compiler.org)
// /Users/danieldonenfeld/Developer/taco/cmake-build-relwithdebinfo/bin/taco "t(i) = f(i) + s(i)" -f=t:d -f=f:r -f=s:r -write-source=temp_vec.c -c -print-compute -print-nocolor
#ifndef TACO_C_HEADERS
#define TACO_C_HEADERS
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <math.h>
#include <complex.h>
#include <string.h>
#define TACO_MIN(_a,_b) ((_a) < (_b) ? (_a) : (_b))
#define TACO_MAX(_a,_b) ((_a) > (_b) ? (_a) : (_b))
#define TACO_LCM(_a,_b) (TODO)
#define TACO_DEREF(_a) (((___context___*)(*__ctx__))->_a)
#ifndef TACO_TENSOR_T_DEFINED
#define TACO_TENSOR_T_DEFINED
typedef enum { taco_mode_dense, taco_mode_sparse } taco_mode_t;
typedef struct {
  int32_t      order;         // tensor order (number of modes)
  int32_t*     dimensions;    // tensor dimensions
  int32_t      csize;         // component size
  int32_t*     mode_ordering; // mode storage ordering
  taco_mode_t* mode_types;    // mode storage types
  uint8_t***   indices;       // tensor index data (per mode)
  uint8_t*     vals;          // tensor values
  int32_t      vals_size;     // values array size
} taco_tensor_t;
#endif
int cmp(const void *a, const void *b) {
  return *((const int*)a) - *((const int*)b);
}
int taco_binarySearchAfter(int *array, int arrayStart, int arrayEnd, int target) {
  if (array[arrayStart] >= target) {
    return arrayStart;
  }
  int lowerBound = arrayStart; // always < target
  int upperBound = arrayEnd; // always >= target
  while (upperBound - lowerBound > 1) {
    int mid = (upperBound + lowerBound) / 2;
    int midValue = array[mid];
    if (midValue < target) {
      lowerBound = mid;
    }
    else if (midValue > target) {
      upperBound = mid;
    }
    else {
      return mid;
    }
  }
  return upperBound;
}
int taco_binarySearchBefore(int *array, int arrayStart, int arrayEnd, int target) {
  if (array[arrayEnd] <= target) {
    return arrayEnd;
  }
  int lowerBound = arrayStart; // always <= target
  int upperBound = arrayEnd; // always > target
  while (upperBound - lowerBound > 1) {
    int mid = (upperBound + lowerBound) / 2;
    int midValue = array[mid];
    if (midValue < target) {
      lowerBound = mid;
    }
    else if (midValue > target) {
      upperBound = mid;
    }
    else {
      return mid;
    }
  }
  return lowerBound;
}
taco_tensor_t* init_taco_tensor_t(int32_t order, int32_t csize,
                                  int32_t* dimensions, int32_t* mode_ordering,
                                  taco_mode_t* mode_types) {
  taco_tensor_t* t = (taco_tensor_t *) malloc(sizeof(taco_tensor_t));
  t->order         = order;
  t->dimensions    = (int32_t *) malloc(order * sizeof(int32_t));
  t->mode_ordering = (int32_t *) malloc(order * sizeof(int32_t));
  t->mode_types    = (taco_mode_t *) malloc(order * sizeof(taco_mode_t));
  t->indices       = (uint8_t ***) malloc(order * sizeof(uint8_t***));
  t->csize         = csize;
  for (int32_t i = 0; i < order; i++) {
    t->dimensions[i]    = dimensions[i];
    t->mode_ordering[i] = mode_ordering[i];
    t->mode_types[i]    = mode_types[i];
    switch (t->mode_types[i]) {
      case taco_mode_dense:
        t->indices[i] = (uint8_t **) malloc(1 * sizeof(uint8_t **));
        break;
      case taco_mode_sparse:
        t->indices[i] = (uint8_t **) malloc(2 * sizeof(uint8_t **));
        break;
    }
  }
  return t;
}
void deinit_taco_tensor_t(taco_tensor_t* t) {
  for (int i = 0; i < t->order; i++) {
    free(t->indices[i]);
  }
  free(t->indices);
  free(t->dimensions);
  free(t->mode_ordering);
  free(t->mode_types);
  free(t);
}
#endif

int compute(taco_tensor_t *t, taco_tensor_t *f, taco_tensor_t *s) {
  int t1_dimension = (int)(t->dimensions[0]);
  double* restrict t_vals = (double*)(t->vals);
  int* restrict f1_pos = (int*)(f->indices[0][0]);
  int* restrict f1_rle = (int*)(f->indices[0][1]);
  double* restrict f_vals = (double*)(f->vals);
  int* restrict s1_pos = (int*)(s->indices[0][0]);
  int* restrict s1_rle = (int*)(s->indices[0][1]);
  double* restrict s_vals = (double*)(s->vals);

  int32_t t_capacity = t1_dimension;
  t_vals = (double*)malloc(sizeof(double) * t_capacity);

  /* mergers */
  /* [LowererImpl::codeToInitializeIteratorVar] repeatIter */
  int32_t ifpos = f1_pos[0];
  int32_t pf1_end = f1_pos[1];
  /* [LowererImpl::codeToInitializeIteratorVar] variables for iterating repeats */
  int32_t f1_pos_off = 0;
  int32_t f1_pos_save = ifpos;
  int32_t f1_rep_iter = 0;
  int32_t ifcoord = 0;
  /* [LowererImpl::codeToInitializeIteratorVar] repeatIter end */
  /* [LowererImpl::codeToInitializeIteratorVar] repeatIter */
  int32_t ispos = s1_pos[0];
  int32_t ps1_end = s1_pos[1];
  /* [LowererImpl::codeToInitializeIteratorVar] variables for iterating repeats */
  int32_t s1_pos_off = 0;
  int32_t s1_pos_save = ispos;
  int32_t s1_rep_iter = 0;
  int32_t iscoord = 0;
  /* [LowererImpl::codeToInitializeIteratorVar] repeatIter end */
  /* rangers */

  while (ifpos < pf1_end && ispos < ps1_end) {
    int32_t locDist = 1;
    int32_t locCount = TACO_MIN(f1_rle[ifpos] - f1_rep_iter,(s1_rle[ispos] - s1_rep_iter));
    for (int32_t pop_iter = 0; pop_iter < TACO_MIN(locCount,locDist); pop_iter++) {
      f1_pos_off = 0;
      f1_pos_save = ifpos;
      ifpos = f1_pos_save + f1_pos_off;
      s1_pos_off = 0;
      s1_pos_save = ispos;
      ispos = s1_pos_save + s1_pos_off;
      t_vals[ifcoord] = f_vals[ifpos] + s_vals[ispos];
      f1_rep_iter++;
      ifcoord++;
      if (f1_rep_iter == f1_rle[ifpos]) {
        f1_rep_iter = 0;
        ifpos = f1_pos_save + 1;
      }
      else {
        ifpos = f1_pos_save;
      }
      s1_rep_iter++;
      iscoord++;
      if (s1_rep_iter == s1_rle[ispos]) {
        s1_rep_iter = 0;
        ispos = s1_pos_save + 1;
      }
      else {
        ispos = s1_pos_save;
      }
    }
    if (locCount > locDist) {
      locCount = locCount - locDist;
      for (int32_t copy_iter = 0; copy_iter < locCount; copy_iter++) {
        t_vals[ifcoord + copy_iter] = t_vals[((ifcoord - locDist) + copy_iter)];
      }
      f1_rep_iter += locCount;
      ifcoord += locCount;
      if (f1_rep_iter == f1_rle[ifpos]) {
        f1_rep_iter = 0;
        ifpos++;
      }
      s1_rep_iter += locCount;
      iscoord += locCount;
      if (s1_rep_iter == s1_rle[ispos]) {
        s1_rep_iter = 0;
        ispos++;
      }
    }
  }

  t->vals = (uint8_t*)t_vals;
  return 0;
}

int assemble(taco_tensor_t *t, taco_tensor_t *f, taco_tensor_t *s) {
  int t1_dimension = (int)(t->dimensions[0]);
  double* restrict t_vals = (double*)(t->vals);

  t_vals = (double*)malloc(sizeof(double) * t1_dimension);

  t->vals = (uint8_t*)t_vals;
  return 0;
}

int evaluate(taco_tensor_t *t, taco_tensor_t *f, taco_tensor_t *s) {
  int t1_dimension = (int)(t->dimensions[0]);
  double* restrict t_vals = (double*)(t->vals);
  int* restrict f1_pos = (int*)(f->indices[0][0]);
  int* restrict f1_rle = (int*)(f->indices[0][1]);
  double* restrict f_vals = (double*)(f->vals);
  int* restrict s1_pos = (int*)(s->indices[0][0]);
  int* restrict s1_rle = (int*)(s->indices[0][1]);
  double* restrict s_vals = (double*)(s->vals);

  int32_t t_capacity = t1_dimension;
  t_vals = (double*)malloc(sizeof(double) * t_capacity);

  /* mergers */
  /* [LowererImpl::codeToInitializeIteratorVar] repeatIter */
  int32_t ifpos = f1_pos[0];
  int32_t pf1_end = f1_pos[1];
  /* [LowererImpl::codeToInitializeIteratorVar] variables for iterating repeats */
  int32_t f1_pos_off = 0;
  int32_t f1_pos_save = ifpos;
  int32_t f1_rep_iter = 0;
  int32_t ifcoord = 0;
  /* [LowererImpl::codeToInitializeIteratorVar] repeatIter end */
  /* [LowererImpl::codeToInitializeIteratorVar] repeatIter */
  int32_t ispos = s1_pos[0];
  int32_t ps1_end = s1_pos[1];
  /* [LowererImpl::codeToInitializeIteratorVar] variables for iterating repeats */
  int32_t s1_pos_off = 0;
  int32_t s1_pos_save = ispos;
  int32_t s1_rep_iter = 0;
  int32_t iscoord = 0;
  /* [LowererImpl::codeToInitializeIteratorVar] repeatIter end */
  /* rangers */

  while (ifpos < pf1_end && ispos < ps1_end) {
    int32_t locDist = 1;
    int32_t locCount = TACO_MIN(f1_rle[ifpos] - f1_rep_iter,(s1_rle[ispos] - s1_rep_iter));
    for (int32_t pop_iter = 0; pop_iter < TACO_MIN(locCount,locDist); pop_iter++) {
      f1_pos_off = 0;
      f1_pos_save = ifpos;
      ifpos = f1_pos_save + f1_pos_off;
      s1_pos_off = 0;
      s1_pos_save = ispos;
      ispos = s1_pos_save + s1_pos_off;
      t_vals[ifcoord] = f_vals[ifpos] + s_vals[ispos];
      f1_rep_iter++;
      ifcoord++;
      if (f1_rep_iter == f1_rle[ifpos]) {
        f1_rep_iter = 0;
        ifpos = f1_pos_save + 1;
      }
      else {
        ifpos = f1_pos_save;
      }
      s1_rep_iter++;
      iscoord++;
      if (s1_rep_iter == s1_rle[ispos]) {
        s1_rep_iter = 0;
        ispos = s1_pos_save + 1;
      }
      else {
        ispos = s1_pos_save;
      }
    }
    if (locCount > locDist) {
      locCount = locCount - locDist;
      for (int32_t copy_iter = 0; copy_iter < locCount; copy_iter++) {
        t_vals[ifcoord + copy_iter] = t_vals[((ifcoord - locDist) + copy_iter)];
      }
      f1_rep_iter += locCount;
      ifcoord += locCount;
      if (f1_rep_iter == f1_rle[ifpos]) {
        f1_rep_iter = 0;
        ifpos++;
      }
      s1_rep_iter += locCount;
      iscoord += locCount;
      if (s1_rep_iter == s1_rle[ispos]) {
        s1_rep_iter = 0;
        ispos++;
      }
    }
  }

  t->vals = (uint8_t*)t_vals;
  return 0;
}

/*
 * The `pack` functions convert coordinate and value arrays in COO format,
 * with nonzeros sorted lexicographically by their coordinates, to the
 * specified input format.
 *
 * The `unpack` function converts the specified output format to coordinate
 * and value arrays in COO format.
 *
 * For both, the `_COO_pos` arrays contain two elements, where the first is 0
 * and the second is the number of nonzeros in the tensor.
 */

int pack_f(taco_tensor_t *f, int* f_COO1_pos, int* f_COO1_crd, double* f_COO_vals) {
  int* restrict f1_pos = (int*)(f->indices[0][0]);
  int* restrict f1_rle = (int*)(f->indices[0][1]);
  double* restrict f_vals = (double*)(f->vals);

  f1_pos = (int32_t*)malloc(sizeof(int32_t) * 2);
  f1_pos[0] = 0;
  int32_t f1_rle_size = 1048576;
  f1_rle = (int32_t*)malloc(sizeof(int32_t) * f1_rle_size);
  int32_t ifpos = 0;
  int32_t f_capacity = 1048576;
  f_vals = (double*)malloc(sizeof(double) * f_capacity);


  /* mergers */
  int32_t if_COOpos = f_COO1_pos[0];
  int32_t pf_COO1_end = f_COO1_pos[1];
  /* rangers */

  while (if_COOpos < pf_COO1_end) {
    /* [lowerMergePoint] loadPosIterCoordinates */
    /* [lowerMergePoint] resolvedCoordinate */
    int32_t i = f_COO1_crd[if_COOpos];
    /* [lowerMergePoint] loadLocatorPosVars */
    /* [lowerMergePoint] deduplicationLoops */
    double f_COO_val = f_COO_vals[if_COOpos];
    if_COOpos++;
    while (if_COOpos < pf_COO1_end && f_COO1_crd[if_COOpos] == i) {
      f_COO_val += f_COO_vals[if_COOpos];
      if_COOpos++;
    }
    /* [lowerMergePoint] caseStmts */
    if (f_capacity <= ifpos) {
      f_vals = (double*)realloc(f_vals, sizeof(double) * (f_capacity * 2));
      f_capacity *= 2;
    }
    f_vals[ifpos] = f_COO_val;
    if (i > 0 && f_vals[ifpos] == f_vals[(ifpos - 1)]) {
      f1_rle[ifpos - 1] = 1 + f1_rle[(ifpos - 1)];
      ifpos = ifpos - 1;
    }
    else {
      if (f1_rle_size <= ifpos) {
        f1_rle = (int32_t*)realloc(f1_rle, sizeof(int32_t) * (f1_rle_size * 2));
        f1_rle_size *= 2;
      }
      f1_rle[ifpos] = 1;
    }
    ifpos++;
    /* [lowerMergePoint] incIteratorVarStmts */
  }

  f1_pos[1] = ifpos;

  f->indices[0][0] = (uint8_t*)(f1_pos);
  f->indices[0][1] = (uint8_t*)(f1_rle);
  f->vals = (uint8_t*)f_vals;
  return 0;
}

int pack_s(taco_tensor_t *s, int* s_COO1_pos, int* s_COO1_crd, double* s_COO_vals) {
  int* restrict s1_pos = (int*)(s->indices[0][0]);
  int* restrict s1_rle = (int*)(s->indices[0][1]);
  double* restrict s_vals = (double*)(s->vals);

  s1_pos = (int32_t*)malloc(sizeof(int32_t) * 2);
  s1_pos[0] = 0;
  int32_t s1_rle_size = 1048576;
  s1_rle = (int32_t*)malloc(sizeof(int32_t) * s1_rle_size);
  int32_t ispos = 0;
  int32_t s_capacity = 1048576;
  s_vals = (double*)malloc(sizeof(double) * s_capacity);


  /* mergers */
  int32_t is_COOpos = s_COO1_pos[0];
  int32_t ps_COO1_end = s_COO1_pos[1];
  /* rangers */

  while (is_COOpos < ps_COO1_end) {
    /* [lowerMergePoint] loadPosIterCoordinates */
    /* [lowerMergePoint] resolvedCoordinate */
    int32_t i = s_COO1_crd[is_COOpos];
    /* [lowerMergePoint] loadLocatorPosVars */
    /* [lowerMergePoint] deduplicationLoops */
    double s_COO_val = s_COO_vals[is_COOpos];
    is_COOpos++;
    while (is_COOpos < ps_COO1_end && s_COO1_crd[is_COOpos] == i) {
      s_COO_val += s_COO_vals[is_COOpos];
      is_COOpos++;
    }
    /* [lowerMergePoint] caseStmts */
    if (s_capacity <= ispos) {
      s_vals = (double*)realloc(s_vals, sizeof(double) * (s_capacity * 2));
      s_capacity *= 2;
    }
    s_vals[ispos] = s_COO_val;
    if (i > 0 && s_vals[ispos] == s_vals[(ispos - 1)]) {
      s1_rle[ispos - 1] = 1 + s1_rle[(ispos - 1)];
      ispos = ispos - 1;
    }
    else {
      if (s1_rle_size <= ispos) {
        s1_rle = (int32_t*)realloc(s1_rle, sizeof(int32_t) * (s1_rle_size * 2));
        s1_rle_size *= 2;
      }
      s1_rle[ispos] = 1;
    }
    ispos++;
    /* [lowerMergePoint] incIteratorVarStmts */
  }

  s1_pos[1] = ispos;

  s->indices[0][0] = (uint8_t*)(s1_pos);
  s->indices[0][1] = (uint8_t*)(s1_rle);
  s->vals = (uint8_t*)s_vals;
  return 0;
}

int unpack(int** t_COO1_pos_ptr, int** t_COO1_crd_ptr, double** t_COO_vals_ptr, taco_tensor_t *t) {
  int* t_COO1_pos;
  int* t_COO1_crd;
  double* t_COO_vals;
  int t1_dimension = (int)(t->dimensions[0]);
  double* restrict t_vals = (double*)(t->vals);

  t_COO1_pos = (int32_t*)malloc(sizeof(int32_t) * 2);
  t_COO1_pos[0] = 0;
  int32_t t_COO1_crd_size = 1048576;
  t_COO1_crd = (int32_t*)malloc(sizeof(int32_t) * t_COO1_crd_size);
  int32_t it_COOpos = 0;
  int32_t t_COO_capacity = 1048576;
  t_COO_vals = (double*)malloc(sizeof(double) * t_COO_capacity);


  for (int32_t i = 0; i < t1_dimension; i++) {
    if (t_COO_capacity <= it_COOpos) {
      t_COO_vals = (double*)realloc(t_COO_vals, sizeof(double) * (t_COO_capacity * 2));
      t_COO_capacity *= 2;
    }
    t_COO_vals[it_COOpos] = t_vals[i];
    if (t_COO1_crd_size <= it_COOpos) {
      t_COO1_crd = (int32_t*)realloc(t_COO1_crd, sizeof(int32_t) * (t_COO1_crd_size * 2));
      t_COO1_crd_size *= 2;
    }
    t_COO1_crd[it_COOpos] = i;
    it_COOpos++;
  }

  t_COO1_pos[1] = it_COOpos;

  *t_COO1_pos_ptr = t_COO1_pos;
  *t_COO1_crd_ptr = t_COO1_crd;
  *t_COO_vals_ptr = t_COO_vals;
  return 0;
}
