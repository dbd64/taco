// Generated by the Tensor Algebra Compiler (tensor-compiler.org)
// /Users/danieldonenfeld/Developer/taco/cmake-build-relwithdebinfo/bin/taco "t(i,j) = f(i,j) + s(i,j)" -f=t:dd -f=f:dr -f=s:dr -write-source=temp.c -c -print-compute -print-nocolor
#ifndef TACO_C_HEADERS
#define TACO_C_HEADERS
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <math.h>
#include <complex.h>
#include <string.h>
#define TACO_MIN(_a,_b) ((_a) < (_b) ? (_a) : (_b))
#define TACO_MAX(_a,_b) ((_a) > (_b) ? (_a) : (_b))
#define TACO_LCM(_a,_b) (TODO)
#define TACO_DEREF(_a) (((___context___*)(*__ctx__))->_a)
#ifndef TACO_TENSOR_T_DEFINED
#define TACO_TENSOR_T_DEFINED
typedef enum { taco_mode_dense, taco_mode_sparse } taco_mode_t;
typedef struct {
  int32_t      order;         // tensor order (number of modes)
  int32_t*     dimensions;    // tensor dimensions
  int32_t      csize;         // component size
  int32_t*     mode_ordering; // mode storage ordering
  taco_mode_t* mode_types;    // mode storage types
  uint8_t***   indices;       // tensor index data (per mode)
  uint8_t*     vals;          // tensor values
  int32_t      vals_size;     // values array size
} taco_tensor_t;
#endif
int cmp(const void *a, const void *b) {
  return *((const int*)a) - *((const int*)b);
}
int taco_binarySearchAfter(int *array, int arrayStart, int arrayEnd, int target) {
  if (array[arrayStart] >= target) {
    return arrayStart;
  }
  int lowerBound = arrayStart; // always < target
  int upperBound = arrayEnd; // always >= target
  while (upperBound - lowerBound > 1) {
    int mid = (upperBound + lowerBound) / 2;
    int midValue = array[mid];
    if (midValue < target) {
      lowerBound = mid;
    }
    else if (midValue > target) {
      upperBound = mid;
    }
    else {
      return mid;
    }
  }
  return upperBound;
}
int taco_binarySearchBefore(int *array, int arrayStart, int arrayEnd, int target) {
  if (array[arrayEnd] <= target) {
    return arrayEnd;
  }
  int lowerBound = arrayStart; // always <= target
  int upperBound = arrayEnd; // always > target
  while (upperBound - lowerBound > 1) {
    int mid = (upperBound + lowerBound) / 2;
    int midValue = array[mid];
    if (midValue < target) {
      lowerBound = mid;
    }
    else if (midValue > target) {
      upperBound = mid;
    }
    else {
      return mid;
    }
  }
  return lowerBound;
}
taco_tensor_t* init_taco_tensor_t(int32_t order, int32_t csize,
                                  int32_t* dimensions, int32_t* mode_ordering,
                                  taco_mode_t* mode_types) {
  taco_tensor_t* t = (taco_tensor_t *) malloc(sizeof(taco_tensor_t));
  t->order         = order;
  t->dimensions    = (int32_t *) malloc(order * sizeof(int32_t));
  t->mode_ordering = (int32_t *) malloc(order * sizeof(int32_t));
  t->mode_types    = (taco_mode_t *) malloc(order * sizeof(taco_mode_t));
  t->indices       = (uint8_t ***) malloc(order * sizeof(uint8_t***));
  t->csize         = csize;
  for (int32_t i = 0; i < order; i++) {
    t->dimensions[i]    = dimensions[i];
    t->mode_ordering[i] = mode_ordering[i];
    t->mode_types[i]    = mode_types[i];
    switch (t->mode_types[i]) {
      case taco_mode_dense:
        t->indices[i] = (uint8_t **) malloc(1 * sizeof(uint8_t **));
        break;
      case taco_mode_sparse:
        t->indices[i] = (uint8_t **) malloc(2 * sizeof(uint8_t **));
        break;
    }
  }
  return t;
}
void deinit_taco_tensor_t(taco_tensor_t* t) {
  for (int i = 0; i < t->order; i++) {
    free(t->indices[i]);
  }
  free(t->indices);
  free(t->dimensions);
  free(t->mode_ordering);
  free(t->mode_types);
  free(t);
}
#endif

int compute(taco_tensor_t *t, taco_tensor_t *f, taco_tensor_t *s) {
  int t1_dimension = (int)(t->dimensions[0]);
  int t2_dimension = (int)(t->dimensions[1]);
  double* restrict t_vals = (double*)(t->vals);
  int f1_dimension = (int)(f->dimensions[0]);
  int* restrict f2_pos = (int*)(f->indices[1][0]);
  int* restrict f2_rle = (int*)(f->indices[1][1]);
  double* restrict f_vals = (double*)(f->vals);
  int s1_dimension = (int)(s->dimensions[0]);
  int* restrict s2_pos = (int*)(s->indices[1][0]);
  int* restrict s2_rle = (int*)(s->indices[1][1]);
  double* restrict s_vals = (double*)(s->vals);

  int32_t t_capacity = t1_dimension * t2_dimension;
  t_vals = (double*)malloc(sizeof(double) * t_capacity);

  #pragma omp parallel for schedule(runtime)
  for (int32_t i = 0; i < s1_dimension; i++) {
    /* mergers */
    /* [LowererImpl::codeToInitializeIteratorVar] repeatIter */
    int32_t jfpos = f2_pos[i];
    int32_t pf2_end = f2_pos[(i + 1)];
    /* [LowererImpl::codeToInitializeIteratorVar] variables for iterating repeats */
    int32_t f2_pos_off = 0;
    int32_t f2_pos_save = jfpos;
    int32_t f2_rep_iter = 0;
    int32_t jfcoord = 0;
    /* [LowererImpl::codeToInitializeIteratorVar] repeatIter end */
    /* [LowererImpl::codeToInitializeIteratorVar] repeatIter */
    int32_t jspos = s2_pos[i];
    int32_t ps2_end = s2_pos[(i + 1)];
    /* [LowererImpl::codeToInitializeIteratorVar] variables for iterating repeats */
    int32_t s2_pos_off = 0;
    int32_t s2_pos_save = jspos;
    int32_t s2_rep_iter = 0;
    int32_t jscoord = 0;
    /* [LowererImpl::codeToInitializeIteratorVar] repeatIter end */
    /* rangers */

    while (jfpos < pf2_end && jspos < ps2_end) {
      int32_t locDist = 1;
      int32_t locCount = TACO_MIN(f2_rle[jfpos] - f2_rep_iter,(s2_rle[jspos] - s2_rep_iter));
      for (int32_t pop_iter = 0; pop_iter < TACO_MIN(locCount,locDist); pop_iter++) {
        f2_pos_off = 0;
        f2_pos_save = jfpos;
        jfpos = f2_pos_save + f2_pos_off;
        s2_pos_off = 0;
        s2_pos_save = jspos;
        jspos = s2_pos_save + s2_pos_off;
        int32_t jtpos = i * t2_dimension + jfcoord;
        t_vals[jtpos] = f_vals[jfpos] + s_vals[jspos];
        f2_rep_iter++;
        jfcoord++;
        if (f2_rep_iter == f2_rle[jfpos]) {
          f2_rep_iter = 0;
          jfpos = f2_pos_save + 1;
        }
        else {
          jfpos = f2_pos_save;
        }
        s2_rep_iter++;
        jscoord++;
        if (s2_rep_iter == s2_rle[jspos]) {
          s2_rep_iter = 0;
          jspos = s2_pos_save + 1;
        }
        else {
          jspos = s2_pos_save;
        }
      }
      if (locCount > locDist) {
        locCount = locCount - locDist;
        for (int32_t copy_iter = 0; copy_iter < locCount; copy_iter++) {
          int32_t jtpos = i * t2_dimension + jfcoord;
          t_vals[jtpos + copy_iter] = t_vals[((jtpos - locDist) + copy_iter)];
        }
        f2_rep_iter += locCount;
        jfcoord += locCount;
        if (f2_rep_iter == f2_rle[jfpos]) {
          f2_rep_iter = 0;
          jfpos++;
        }
        s2_rep_iter += locCount;
        jscoord += locCount;
        if (s2_rep_iter == s2_rle[jspos]) {
          s2_rep_iter = 0;
          jspos++;
        }
      }
    }
  }

  t->vals = (uint8_t*)t_vals;
  return 0;
}

int assemble(taco_tensor_t *t, taco_tensor_t *f, taco_tensor_t *s) {
  int t1_dimension = (int)(t->dimensions[0]);
  int t2_dimension = (int)(t->dimensions[1]);
  double* restrict t_vals = (double*)(t->vals);

  t_vals = (double*)malloc(sizeof(double) * (t1_dimension * t2_dimension));

  t->vals = (uint8_t*)t_vals;
  return 0;
}

int evaluate(taco_tensor_t *t, taco_tensor_t *f, taco_tensor_t *s) {
  int t1_dimension = (int)(t->dimensions[0]);
  int t2_dimension = (int)(t->dimensions[1]);
  double* restrict t_vals = (double*)(t->vals);
  int f1_dimension = (int)(f->dimensions[0]);
  int* restrict f2_pos = (int*)(f->indices[1][0]);
  int* restrict f2_rle = (int*)(f->indices[1][1]);
  double* restrict f_vals = (double*)(f->vals);
  int s1_dimension = (int)(s->dimensions[0]);
  int* restrict s2_pos = (int*)(s->indices[1][0]);
  int* restrict s2_rle = (int*)(s->indices[1][1]);
  double* restrict s_vals = (double*)(s->vals);

  int32_t t_capacity = t1_dimension * t2_dimension;
  t_vals = (double*)malloc(sizeof(double) * t_capacity);

  #pragma omp parallel for schedule(runtime)
  for (int32_t i = 0; i < s1_dimension; i++) {
    /* mergers */
    /* [LowererImpl::codeToInitializeIteratorVar] repeatIter */
    int32_t jfpos = f2_pos[i];
    int32_t pf2_end = f2_pos[(i + 1)];
    /* [LowererImpl::codeToInitializeIteratorVar] variables for iterating repeats */
    int32_t f2_pos_off = 0;
    int32_t f2_pos_save = jfpos;
    int32_t f2_rep_iter = 0;
    int32_t jfcoord = 0;
    /* [LowererImpl::codeToInitializeIteratorVar] repeatIter end */
    /* [LowererImpl::codeToInitializeIteratorVar] repeatIter */
    int32_t jspos = s2_pos[i];
    int32_t ps2_end = s2_pos[(i + 1)];
    /* [LowererImpl::codeToInitializeIteratorVar] variables for iterating repeats */
    int32_t s2_pos_off = 0;
    int32_t s2_pos_save = jspos;
    int32_t s2_rep_iter = 0;
    int32_t jscoord = 0;
    /* [LowererImpl::codeToInitializeIteratorVar] repeatIter end */
    /* rangers */

    while (jfpos < pf2_end && jspos < ps2_end) {
      int32_t locDist = 1;
      int32_t locCount = TACO_MIN(f2_rle[jfpos] - f2_rep_iter,(s2_rle[jspos] - s2_rep_iter));
      for (int32_t pop_iter = 0; pop_iter < TACO_MIN(locCount,locDist); pop_iter++) {
        f2_pos_off = 0;
        f2_pos_save = jfpos;
        jfpos = f2_pos_save + f2_pos_off;
        s2_pos_off = 0;
        s2_pos_save = jspos;
        jspos = s2_pos_save + s2_pos_off;
        int32_t jtpos = i * t2_dimension + jfcoord;
        t_vals[jtpos] = f_vals[jfpos] + s_vals[jspos];
        f2_rep_iter++;
        jfcoord++;
        if (f2_rep_iter == f2_rle[jfpos]) {
          f2_rep_iter = 0;
          jfpos = f2_pos_save + 1;
        }
        else {
          jfpos = f2_pos_save;
        }
        s2_rep_iter++;
        jscoord++;
        if (s2_rep_iter == s2_rle[jspos]) {
          s2_rep_iter = 0;
          jspos = s2_pos_save + 1;
        }
        else {
          jspos = s2_pos_save;
        }
      }
      if (locCount > locDist) {
        locCount = locCount - locDist;
        for (int32_t copy_iter = 0; copy_iter < locCount; copy_iter++) {
          int32_t jtpos = i * t2_dimension + jfcoord;
          t_vals[jtpos + copy_iter] = t_vals[((jtpos - locDist) + copy_iter)];
        }
        f2_rep_iter += locCount;
        jfcoord += locCount;
        if (f2_rep_iter == f2_rle[jfpos]) {
          f2_rep_iter = 0;
          jfpos++;
        }
        s2_rep_iter += locCount;
        jscoord += locCount;
        if (s2_rep_iter == s2_rle[jspos]) {
          s2_rep_iter = 0;
          jspos++;
        }
      }
    }
  }

  t->vals = (uint8_t*)t_vals;
  return 0;
}

/*
 * The `pack` functions convert coordinate and value arrays in COO format,
 * with nonzeros sorted lexicographically by their coordinates, to the
 * specified input format.
 *
 * The `unpack` function converts the specified output format to coordinate
 * and value arrays in COO format.
 *
 * For both, the `_COO_pos` arrays contain two elements, where the first is 0
 * and the second is the number of nonzeros in the tensor.
 */

int pack_f(taco_tensor_t *f, int* f_COO1_pos, int* f_COO1_crd, int* f_COO2_crd, double* f_COO_vals) {
  int f1_dimension = (int)(f->dimensions[0]);
  int* restrict f2_pos = (int*)(f->indices[1][0]);
  int* restrict f2_rle = (int*)(f->indices[1][1]);
  double* restrict f_vals = (double*)(f->vals);

  f2_pos = (int32_t*)malloc(sizeof(int32_t) * (f1_dimension + 1));
  f2_pos[0] = 0;
  for (int32_t pf2 = 1; pf2 < (f1_dimension + 1); pf2++) {
    f2_pos[pf2] = 0;
  }
  int32_t f2_rle_size = 1048576;
  f2_rle = (int32_t*)malloc(sizeof(int32_t) * f2_rle_size);
  int32_t jfpos = 0;
  int32_t f_capacity = 1048576;
  f_vals = (double*)malloc(sizeof(double) * f_capacity);

  /* mergers */
  int32_t if_COOpos = f_COO1_pos[0];
  int32_t pf_COO1_end = f_COO1_pos[1];
  /* rangers */

  while (if_COOpos < pf_COO1_end) {
    /* [lowerMergePoint] loadPosIterCoordinates */
    /* [lowerMergePoint] resolvedCoordinate */
    int32_t i = f_COO1_crd[if_COOpos];
    /* [lowerMergePoint] loadLocatorPosVars */
    /* [lowerMergePoint] deduplicationLoops */
    int32_t f_COO1_segend = if_COOpos + 1;
    while (f_COO1_segend < pf_COO1_end && f_COO1_crd[f_COO1_segend] == i) {
      f_COO1_segend++;
    }
    /* [lowerMergePoint] caseStmts */
    int32_t pf2_begin = jfpos;

    /* mergers */
    int32_t jf_COOpos = if_COOpos;
    /* rangers */

    while (jf_COOpos < f_COO1_segend) {
      /* [lowerMergePoint] loadPosIterCoordinates */
      /* [lowerMergePoint] resolvedCoordinate */
      int32_t j = f_COO2_crd[jf_COOpos];
      /* [lowerMergePoint] loadLocatorPosVars */
      /* [lowerMergePoint] deduplicationLoops */
      double f_COO_val = f_COO_vals[jf_COOpos];
      jf_COOpos++;
      while (jf_COOpos < f_COO1_segend && f_COO2_crd[jf_COOpos] == j) {
        f_COO_val += f_COO_vals[jf_COOpos];
        jf_COOpos++;
      }
      /* [lowerMergePoint] caseStmts */
      if (f_capacity <= jfpos) {
        f_vals = (double*)realloc(f_vals, sizeof(double) * (f_capacity * 2));
        f_capacity *= 2;
      }
      f_vals[jfpos] = f_COO_val;
      if (j > 0 && f_vals[jfpos] == f_vals[(jfpos - 1)]) {
        f2_rle[jfpos - 1] = 1 + f2_rle[(jfpos - 1)];
        jfpos = jfpos - 1;
      }
      else {
        if (f2_rle_size <= jfpos) {
          f2_rle = (int32_t*)realloc(f2_rle, sizeof(int32_t) * (f2_rle_size * 2));
          f2_rle_size *= 2;
        }
        f2_rle[jfpos] = 1;
      }
      jfpos++;
      /* [lowerMergePoint] incIteratorVarStmts */
    }

    f2_pos[i + 1] = jfpos - pf2_begin;
    /* [lowerMergePoint] incIteratorVarStmts */
    if_COOpos = f_COO1_segend;
  }

  int32_t csf2 = 0;
  for (int32_t pf20 = 1; pf20 < (f1_dimension + 1); pf20++) {
    csf2 += f2_pos[pf20];
    f2_pos[pf20] = csf2;
  }

  f->indices[1][0] = (uint8_t*)(f2_pos);
  f->indices[1][1] = (uint8_t*)(f2_rle);
  f->vals = (uint8_t*)f_vals;
  return 0;
}

int pack_s(taco_tensor_t *s, int* s_COO1_pos, int* s_COO1_crd, int* s_COO2_crd, double* s_COO_vals) {
  int s1_dimension = (int)(s->dimensions[0]);
  int* restrict s2_pos = (int*)(s->indices[1][0]);
  int* restrict s2_rle = (int*)(s->indices[1][1]);
  double* restrict s_vals = (double*)(s->vals);

  s2_pos = (int32_t*)malloc(sizeof(int32_t) * (s1_dimension + 1));
  s2_pos[0] = 0;
  for (int32_t ps2 = 1; ps2 < (s1_dimension + 1); ps2++) {
    s2_pos[ps2] = 0;
  }
  int32_t s2_rle_size = 1048576;
  s2_rle = (int32_t*)malloc(sizeof(int32_t) * s2_rle_size);
  int32_t jspos = 0;
  int32_t s_capacity = 1048576;
  s_vals = (double*)malloc(sizeof(double) * s_capacity);

  /* mergers */
  int32_t is_COOpos = s_COO1_pos[0];
  int32_t ps_COO1_end = s_COO1_pos[1];
  /* rangers */

  while (is_COOpos < ps_COO1_end) {
    /* [lowerMergePoint] loadPosIterCoordinates */
    /* [lowerMergePoint] resolvedCoordinate */
    int32_t i = s_COO1_crd[is_COOpos];
    /* [lowerMergePoint] loadLocatorPosVars */
    /* [lowerMergePoint] deduplicationLoops */
    int32_t s_COO1_segend = is_COOpos + 1;
    while (s_COO1_segend < ps_COO1_end && s_COO1_crd[s_COO1_segend] == i) {
      s_COO1_segend++;
    }
    /* [lowerMergePoint] caseStmts */
    int32_t ps2_begin = jspos;

    /* mergers */
    int32_t js_COOpos = is_COOpos;
    /* rangers */

    while (js_COOpos < s_COO1_segend) {
      /* [lowerMergePoint] loadPosIterCoordinates */
      /* [lowerMergePoint] resolvedCoordinate */
      int32_t j = s_COO2_crd[js_COOpos];
      /* [lowerMergePoint] loadLocatorPosVars */
      /* [lowerMergePoint] deduplicationLoops */
      double s_COO_val = s_COO_vals[js_COOpos];
      js_COOpos++;
      while (js_COOpos < s_COO1_segend && s_COO2_crd[js_COOpos] == j) {
        s_COO_val += s_COO_vals[js_COOpos];
        js_COOpos++;
      }
      /* [lowerMergePoint] caseStmts */
      if (s_capacity <= jspos) {
        s_vals = (double*)realloc(s_vals, sizeof(double) * (s_capacity * 2));
        s_capacity *= 2;
      }
      s_vals[jspos] = s_COO_val;
      if (j > 0 && s_vals[jspos] == s_vals[(jspos - 1)]) {
        s2_rle[jspos - 1] = 1 + s2_rle[(jspos - 1)];
        jspos = jspos - 1;
      }
      else {
        if (s2_rle_size <= jspos) {
          s2_rle = (int32_t*)realloc(s2_rle, sizeof(int32_t) * (s2_rle_size * 2));
          s2_rle_size *= 2;
        }
        s2_rle[jspos] = 1;
      }
      jspos++;
      /* [lowerMergePoint] incIteratorVarStmts */
    }

    s2_pos[i + 1] = jspos - ps2_begin;
    /* [lowerMergePoint] incIteratorVarStmts */
    is_COOpos = s_COO1_segend;
  }

  int32_t css2 = 0;
  for (int32_t ps20 = 1; ps20 < (s1_dimension + 1); ps20++) {
    css2 += s2_pos[ps20];
    s2_pos[ps20] = css2;
  }

  s->indices[1][0] = (uint8_t*)(s2_pos);
  s->indices[1][1] = (uint8_t*)(s2_rle);
  s->vals = (uint8_t*)s_vals;
  return 0;
}

int unpack(int** t_COO1_pos_ptr, int** t_COO1_crd_ptr, int** t_COO2_crd_ptr, double** t_COO_vals_ptr, taco_tensor_t *t) {
  int* t_COO1_pos;
  int* t_COO1_crd;
  int* t_COO2_crd;
  double* t_COO_vals;
  int t1_dimension = (int)(t->dimensions[0]);
  int t2_dimension = (int)(t->dimensions[1]);
  double* restrict t_vals = (double*)(t->vals);

  t_COO1_pos = (int32_t*)malloc(sizeof(int32_t) * 2);
  t_COO1_pos[0] = 0;
  int32_t t_COO1_crd_size = 1048576;
  t_COO1_crd = (int32_t*)malloc(sizeof(int32_t) * t_COO1_crd_size);
  int32_t t_COO2_crd_size = 1048576;
  t_COO2_crd = (int32_t*)malloc(sizeof(int32_t) * t_COO2_crd_size);
  int32_t jt_COOpos = 0;
  int32_t t_COO_capacity = 1048576;
  t_COO_vals = (double*)malloc(sizeof(double) * t_COO_capacity);


  for (int32_t i = 0; i < t1_dimension; i++) {
    for (int32_t j = 0; j < t2_dimension; j++) {
      if (t_COO_capacity <= jt_COOpos) {
        t_COO_vals = (double*)realloc(t_COO_vals, sizeof(double) * (t_COO_capacity * 2));
        t_COO_capacity *= 2;
      }
      int32_t jtpos = i * t2_dimension + j;
      t_COO_vals[jt_COOpos] = t_vals[jtpos];
      if (t_COO2_crd_size <= jt_COOpos) {
        int32_t t_COO2_crd_new_size = TACO_MAX(t_COO2_crd_size * 2,(jt_COOpos + 1));
        t_COO2_crd = (int32_t*)realloc(t_COO2_crd, sizeof(int32_t) * t_COO2_crd_new_size);
        t_COO2_crd_size = t_COO2_crd_new_size;
      }
      t_COO2_crd[jt_COOpos] = j;
      if (t_COO1_crd_size <= jt_COOpos) {
        t_COO1_crd = (int32_t*)realloc(t_COO1_crd, sizeof(int32_t) * (t_COO1_crd_size * 2));
        t_COO1_crd_size *= 2;
      }
      t_COO1_crd[jt_COOpos] = i;
      jt_COOpos++;
    }
  }

  t_COO1_pos[1] = jt_COOpos;

  *t_COO1_pos_ptr = t_COO1_pos;
  *t_COO1_crd_ptr = t_COO1_crd;
  *t_COO2_crd_ptr = t_COO2_crd;
  *t_COO_vals_ptr = t_COO_vals;
  return 0;
}
