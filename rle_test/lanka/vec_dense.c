// Generated by the Tensor Algebra Compiler (tensor-compiler.org)
// /Users/danieldonenfeld/Developer/taco/cmake-build-debug/bin/taco "t(i) = f(i)+ s(i)" -c -write-source=temp_vec_dense.c
#ifndef TACO_C_HEADERS
#define TACO_C_HEADERS
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <math.h>
#include <complex.h>
#include <string.h>
#define TACO_MIN(_a,_b) ((_a) < (_b) ? (_a) : (_b))
#define TACO_MAX(_a,_b) ((_a) > (_b) ? (_a) : (_b))
#define TACO_LCM(_a,_b) (TODO)
#define TACO_DEREF(_a) (((___context___*)(*__ctx__))->_a)
#ifndef TACO_TENSOR_T_DEFINED
#define TACO_TENSOR_T_DEFINED
typedef enum { taco_mode_dense, taco_mode_sparse } taco_mode_t;
typedef struct {
  int32_t      order;         // tensor order (number of modes)
  int32_t*     dimensions;    // tensor dimensions
  int32_t      csize;         // component size
  int32_t*     mode_ordering; // mode storage ordering
  taco_mode_t* mode_types;    // mode storage types
  uint8_t***   indices;       // tensor index data (per mode)
  uint8_t*     vals;          // tensor values
  int32_t      vals_size;     // values array size
} taco_tensor_t;
#endif
#endif

int compute_dense(taco_tensor_t *t, taco_tensor_t *f, taco_tensor_t *s) {
  int t1_dimension = (int)(t->dimensions[0]);
  double* restrict t_vals = (double*)(t->vals);
  int f1_dimension = (int)(f->dimensions[0]);
  double* restrict f_vals = (double*)(f->vals);
  int s1_dimension = (int)(s->dimensions[0]);
  double* restrict s_vals = (double*)(s->vals);

  int32_t t_capacity = t1_dimension;
  t_vals = (double*)malloc(sizeof(double) * t_capacity);

  #pragma omp parallel for schedule(runtime)
  for (int32_t i = 0; i < s1_dimension; i++) {
    t_vals[i] = f_vals[i] + s_vals[i];
  }

  t->vals = (uint8_t*)t_vals;
  return 0;
}

int assemble_dense(taco_tensor_t *t, taco_tensor_t *f, taco_tensor_t *s) {
  int t1_dimension = (int)(t->dimensions[0]);
  double* restrict t_vals = (double*)(t->vals);

  t_vals = (double*)malloc(sizeof(double) * t1_dimension);

  t->vals = (uint8_t*)t_vals;
  return 0;
}

int evaluate_dense(taco_tensor_t *t, taco_tensor_t *f, taco_tensor_t *s) {
  int t1_dimension = (int)(t->dimensions[0]);
  double* restrict t_vals = (double*)(t->vals);
  int f1_dimension = (int)(f->dimensions[0]);
  double* restrict f_vals = (double*)(f->vals);
  int s1_dimension = (int)(s->dimensions[0]);
  double* restrict s_vals = (double*)(s->vals);

  int32_t t_capacity = t1_dimension;
  t_vals = (double*)malloc(sizeof(double) * t_capacity);

  #pragma omp parallel for schedule(runtime)
  for (int32_t i = 0; i < s1_dimension; i++) {
    t_vals[i] = f_vals[i] + s_vals[i];
  }

  t->vals = (uint8_t*)t_vals;
  return 0;
}

/*
 * The `pack` functions convert coordinate and value arrays in COO format,
 * with nonzeros sorted lexicographically by their coordinates, to the
 * specified input format.
 *
 * The `unpack` function converts the specified output format to coordinate
 * and value arrays in COO format.
 *
 * For both, the `_COO_pos` arrays contain two elements, where the first is 0
 * and the second is the number of nonzeros in the tensor.
 */

int pack_f_dense(taco_tensor_t *f, int* f_COO1_pos, int* f_COO1_crd, double* f_COO_vals) {
  int f1_dimension = (int)(f->dimensions[0]);
  double* restrict f_vals = (double*)(f->vals);

  int32_t f_capacity = f1_dimension;
  f_vals = (double*)malloc(sizeof(double) * f_capacity);

  #pragma omp parallel for schedule(static)
  for (int32_t pf = 0; pf < f_capacity; pf++) {
    f_vals[pf] = 0.0;
  }

  /* mergers */
  int32_t if_COOpos = f_COO1_pos[0];
  int32_t pf_COO1_end = f_COO1_pos[1];
  /* rangers */

  while (if_COOpos < pf_COO1_end) {
    /* [lowerMergePoint] loadPosIterCoordinates */
    /* [lowerMergePoint] resolvedCoordinate */
    int32_t i = f_COO1_crd[if_COOpos];
    /* [lowerMergePoint] loadLocatorPosVars */
    /* [lowerMergePoint] deduplicationLoops */
    double f_COO_val = f_COO_vals[if_COOpos];
    if_COOpos++;
    while (if_COOpos < pf_COO1_end && f_COO1_crd[if_COOpos] == i) {
      f_COO_val += f_COO_vals[if_COOpos];
      if_COOpos++;
    }
    /* [lowerMergePoint] caseStmts */
    f_vals[i] = f_COO_val;
    /* [lowerMergePoint] incIteratorVarStmts */
  }

  f->vals = (uint8_t*)f_vals;
  return 0;
}

int pack_s_dense(taco_tensor_t *s, int* s_COO1_pos, int* s_COO1_crd, double* s_COO_vals) {
  int s1_dimension = (int)(s->dimensions[0]);
  double* restrict s_vals = (double*)(s->vals);

  int32_t s_capacity = s1_dimension;
  s_vals = (double*)malloc(sizeof(double) * s_capacity);

  #pragma omp parallel for schedule(static)
  for (int32_t ps = 0; ps < s_capacity; ps++) {
    s_vals[ps] = 0.0;
  }

  /* mergers */
  int32_t is_COOpos = s_COO1_pos[0];
  int32_t ps_COO1_end = s_COO1_pos[1];
  /* rangers */

  while (is_COOpos < ps_COO1_end) {
    /* [lowerMergePoint] loadPosIterCoordinates */
    /* [lowerMergePoint] resolvedCoordinate */
    int32_t i = s_COO1_crd[is_COOpos];
    /* [lowerMergePoint] loadLocatorPosVars */
    /* [lowerMergePoint] deduplicationLoops */
    double s_COO_val = s_COO_vals[is_COOpos];
    is_COOpos++;
    while (is_COOpos < ps_COO1_end && s_COO1_crd[is_COOpos] == i) {
      s_COO_val += s_COO_vals[is_COOpos];
      is_COOpos++;
    }
    /* [lowerMergePoint] caseStmts */
    s_vals[i] = s_COO_val;
    /* [lowerMergePoint] incIteratorVarStmts */
  }

  s->vals = (uint8_t*)s_vals;
  return 0;
}

int unpack_dense(int** t_COO1_pos_ptr, int** t_COO1_crd_ptr, double** t_COO_vals_ptr, taco_tensor_t *t) {
  int* t_COO1_pos;
  int* t_COO1_crd;
  double* t_COO_vals;
  int t1_dimension = (int)(t->dimensions[0]);
  double* restrict t_vals = (double*)(t->vals);

  t_COO1_pos = (int32_t*)malloc(sizeof(int32_t) * 2);
  t_COO1_pos[0] = 0;
  int32_t t_COO1_crd_size = 1048576;
  t_COO1_crd = (int32_t*)malloc(sizeof(int32_t) * t_COO1_crd_size);
  int32_t it_COOpos = 0;
  int32_t t_COO_capacity = 1048576;
  t_COO_vals = (double*)malloc(sizeof(double) * t_COO_capacity);


  for (int32_t i = 0; i < t1_dimension; i++) {
    if (t_COO_capacity <= it_COOpos) {
      t_COO_vals = (double*)realloc(t_COO_vals, sizeof(double) * (t_COO_capacity * 2));
      t_COO_capacity *= 2;
    }
    t_COO_vals[it_COOpos] = t_vals[i];
    if (t_COO1_crd_size <= it_COOpos) {
      t_COO1_crd = (int32_t*)realloc(t_COO1_crd, sizeof(int32_t) * (t_COO1_crd_size * 2));
      t_COO1_crd_size *= 2;
    }
    t_COO1_crd[it_COOpos] = i;
    it_COOpos++;
  }

  t_COO1_pos[1] = it_COOpos;

  *t_COO1_pos_ptr = t_COO1_pos;
  *t_COO1_crd_ptr = t_COO1_crd;
  *t_COO_vals_ptr = t_COO_vals;
  return 0;
}
